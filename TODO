
* gestion des erreurs
   logging systématique des erreurs et warnings
   
   création d'un message depuis un packet réseau (frombytes) : non strict et
   conservation des erreurs dans le message

   création explicite d'un message par son constructeur : mode strict
   et exception

   
   

* Création des Headers
à la création du message : message(*headers, **kw)
ou plus tard avec message.addheaders(*headers, **kw)

Les headers sont des arguments de type bytes ou str (convertis en
bytes par encodage utf-8). Ils doivent être conforme à la RFC 3261
pour un header générique 
 header-name LWS COLON header-value
avec les contraintes pour les headers spécifiques SIP. Il peut également
s'agir d'une liste de headers séparés par \r\n. ex :
REGISTER(requri, 'Via: SIP/2.0/UDP 172.20.35.253;branch=z9hG4bK_AAA')
REGISTER(requri, b'''Via: SIP/2.0/UDP 172.20.35.253;branch=z9hG4bK_AAA\r
From: <sip:+33900821220@osk.nokims.eu>;tag=y258e1J5BSgX5YCzxGEVY1wL\r
To: <sip:+33900821220@osk.nokims.eu>\r
Call-ID: 9370womCjjVJK9sRM.a94HbEd\r''')
Une exception ValueError est levée en cas d'erreur de parsing sauf si
strictparsing est faux (par défaut) auquel cas l'exception est
conservée dans la liste message.errors

   
Les kw sont des keyword arguments pour les champs principaux
   des messages (cf ci-dessous)

REGISTER(requri, branch='z9hG4bK_AAA', from='sip:+33900821220@osk.nokims.eu')

   

* Ajout automatique des Headers obligatoires à la création du message
   register = REGISTER('sip:domain.com')

   Via, From, To, Max-Forward, Call-ID, Content-Length...

   
* Raccourcis pour les champs principaux (getter et setter)
   message.branch : paramètre branch du premier Via
   message.sent_by : sent-by du premier Via
   message.protocol : protocol du premier Via
   message.fromtag : paramètre tag du premier From
   message.totag : paramètre tag du premier To
   message.id : n° du premier Call-ID
   message.seq : n° du premier CSeq
   message.length : valeur du du premier Content-Length
   message.type : valeur du du premier Content-Type
   

* Récupération/Modification des Headers
   getheaders([name] [,name...]) liste des Header filtrée par nom (ou tous)
   getheader(name) retourne le premier Header désigné

   setheaders(name, items) remplace la liste des Header 'name'
   setheader(name, item) remplace le premier Header désigné

   ack.setheaders('callid', invite.getheaders('callid'))
   register.setheader('from', 'sip:alice@toto.com')



* Headers syntaxiquement incorect
   string préfixée par # (fonctionne aussi pour Request-URI)

   REGISTER('#xxx', '#Via: blabla', Route = '#xxx')
   message.headers['Via0'] = '#blibli'

   c'est par ce biais que l'on désactive l'ajout automatique des
   headers obligatoires
   REGISTER('xxxx', Content_length='#')
   



   

* méthode Request.addauthorizatrion(self, response, **args) 
   avec args: username= password=

   ajoute à self un Header Authorization pour chaque Header
   www-Authenticate de response

   ajoute à self un Header Proxy-Authorization pour chaque Header
   Proxy-Authenticate de response
      


   
     
* DISCUSSION

méthode message.addheader(name, *, first=False, **kwargs)
   
ex:
register.addheader('From', display=None, addr='xxx', params={})

   mais pourquoi pas plutôt
register.addheader('From', 'sip:a@b.c')
   qui est plus conforme aux autres fonctions de création

on retombe alors sur la fonction addheaderS existante:
register.addheaders(_from='sip:a@b.c')   
register.addheaders('From:sip:a@b.c')

donc NON pas de message.addheader()
   mais on peut placer un _ final pour insérer un header en début de liste
register.addheaders(via_='xx')   
   
   


en revanche on peut avoir   
headers.add(name, *, first=False, **kwargs)

avec vérification stricte de la présence des arguments
mplique l'existence pour chaque header d'une liste définie dans
SIPBNF des paramètres et donc une documentation plus simple


message.popheader(name)
headers.pop(name) 